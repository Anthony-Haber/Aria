#!/usr/bin/env python3
"""
Real-time Ableton bridge for Aria.

Reads live MIDI from loopMIDI port "ARIA_IN" and sends generated continuations
to "ARIA_OUT", synchronized to Ableton's MIDI clock.

Usage:
    python ableton_bridge.py --in ARIA_IN --out ARIA_OUT [--options]
    # Manual, keyboard-triggered recording (no Ableton clock required):
    python ableton_bridge.py --mode manual --manual-key r --in ARIA_IN --out ARIA_OUT
"""

import argparse
import logging
import os
import sys
import threading
import queue
from pathlib import Path
from typing import Optional, Dict

try:
    from core.datastore import DataStore
except ImportError:  # Package import path
    from .core.datastore import DataStore

# Logging
logging.basicConfig(
    level=logging.INFO,
    format='[%(levelname)s %(asctime)s] %(name)s: %(message)s',
    datefmt='%H:%M:%S',
)
logger = logging.getLogger(__name__)


def find_checkpoint(checkpoint_hint: Optional[str] = None) -> str:
    """
    Locate the checkpoint file. 
    
    Args:
        checkpoint_hint: Explicit path provided by user, or None to search defaults.
    
    Returns:
        Path to checkpoint file.
    
    Raises:
        FileNotFoundError: If checkpoint cannot be found.
    """
    # If user provided a path, use it directly
    if checkpoint_hint:
        if os.path.isfile(checkpoint_hint):
            logger.info(f"Using checkpoint: {checkpoint_hint}")
            return checkpoint_hint
        
        # Try relative paths from script location
        rel_paths = [
            Path(checkpoint_hint),
            Path(__file__).parent / checkpoint_hint,
            Path(__file__).parent.parent / checkpoint_hint,
        ]
        for p in rel_paths:
            if p.exists():
                logger.info(f"Found checkpoint: {p}")
                return str(p.resolve())

    # If no hint or hint not found, search default locations
    default_paths = [
        Path("models/model-gen.safetensors"),
        Path(__file__).parent / "models" / "model-gen.safetensors",
        Path(__file__).parent.parent / "models" / "model-gen.safetensors",
    ]

    for p in default_paths:
        if p.exists():
            logger.info(f"Found checkpoint at default location: {p}")
            return str(p.resolve())

    # Not found
    if checkpoint_hint:
        raise FileNotFoundError(
            f"Could not find checkpoint '{checkpoint_hint}'. "
            f"Searched: {[str(p) for p in rel_paths]}. "
            f"Provide --checkpoint with correct path."
        )
    else:
        raise FileNotFoundError(
            f"No checkpoint found. Please provide --checkpoint with path to model.safetensors. "
            f"Example: python ableton_bridge.py --checkpoint ../models/model-gen.safetensors "
            f"--in ARIA_IN --out ARIA_OUT"
        )


def get_midi_ports():
    """
    List available MIDI ports (input and output).
    """
    try:
        import mido
        logger.info("Available MIDI input ports:")
        for port in mido.get_input_names():
            logger.info(f"  - {port}")
        logger.info("Available MIDI output ports:")
        for port in mido.get_output_names():
            logger.info(f"  - {port}")
    except Exception as e:
        logger.warning(f"Could not list MIDI ports: {e}")


def sync_state_on_startup(osc_controller, timeout: float = 2.0):
    """
    Kick off the OSC controller's initial state sync and return the received state.
    """
    if not osc_controller:
        return None
    try:
        return osc_controller.sync_state_on_startup(timeout=timeout)
    except Exception as e:
        logger.warning(f"OSC startup sync failed: {e}")
        return None


class FeedbackManager:
    def __init__(self, datastore: DataStore):
        self.datastore = datastore
        self.lock = threading.Lock()
        self.current_episode_id: Optional[str] = None
        self.waiting_for_commit: bool = False
        self.latest_grade: Optional[int] = None

    def record_generation(self, prompt_bytes: bytes, output_bytes: bytes, params: Dict, mode: str) -> Optional[str]:
        with self.lock:
            if self.waiting_for_commit:
                logger.warning("Feedback episode already pending commit; skipping new episode.")
                return None
            episode_id = self.datastore.create_episode(prompt_bytes, output_bytes, params, mode=mode)
            self.current_episode_id = episode_id
            self.waiting_for_commit = True
            return episode_id

    def set_grade(self, grade: int):
        with self.lock:
            self.latest_grade = int(grade)

    def commit(self):
        with self.lock:
            if not self.waiting_for_commit or not self.current_episode_id:
                logger.info("No pending feedback episode to commit.")
                return
            grade = self.latest_grade if self.latest_grade is not None else 0
            self.datastore.finalize_episode(self.current_episode_id, grade)
            logger.info(f"Feedback episode {self.current_episode_id} finalized with grade={grade}.")
            self.current_episode_id = None
            self.waiting_for_commit = False
            self.latest_grade = None


def main():
    parser = argparse.ArgumentParser(
        description="Real-time Aria + Ableton bridge",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__,
    )
    parser.add_argument(
        "--in",
        dest="in_port",
        default="ARIA_IN",
        help="Input MIDI port name (default: ARIA_IN)",
    )
    parser.add_argument(
        "--out",
        dest="out_port",
        default="ARIA_OUT",
        help="Output MIDI port name (default: ARIA_OUT)",
    )
    parser.add_argument(
        "--checkpoint",
        default=None,
        help="Path to Aria checkpoint (required unless using --feedback-only). "
             "Can be relative (e.g., '../models/model-gen.safetensors') or absolute.",
    )
    parser.add_argument(
        "--listen_seconds",
        type=float,
        default=4.0,
        help="Duration to listen for human input before generating (default: 4.0)",
    )
    parser.add_argument(
        "--gen_seconds",
        type=float,
        default=1.0,
        help="Duration of continuation to generate (default: 1.0)",
    )
    parser.add_argument(
        "--cooldown_seconds",
        type=float,
        default=0.2,
        help="Cooldown after generation before listening again (default: 0.2)",
    )
    parser.add_argument(
        "--clock_in",
        dest="clock_in",
        default="ARIA_CLOCK",
        help="MIDI clock input port name (default: ARIA_CLOCK)",
    )
    parser.add_argument(
        "--measures",
        type=int,
        default=2,
        help="Number of measures per human/model block (default: 2)",
    )
    parser.add_argument(
        "--beats_per_bar",
        type=int,
        default=4,
        help="Beats per bar (time signature numerator, default: 4)",
    )
    parser.add_argument(
        "--gen_measures",
        type=int,
        default=None,
        help="Measures to generate (default: same as --measures)",
    )
    parser.add_argument(
        "--human_measures",
        type=int,
        default=1,
        help="Number of human measures to collect before generating (default: 1)",
    )
    parser.add_argument(
        "--quantize",
        action="store_true",
        help="Quantize generated output to 1/16 note grid (default: off)",
    )
    parser.add_argument(
        "--ticks_per_beat",
        type=int,
        default=480,
        help="MIDI ticks per quarter note (default: 480)",
    )
    parser.add_argument(
        "--temperature",
        type=float,
        default=0.9,
        help="Sampling temperature (default: 0.9)",
    )
    parser.add_argument(
        "--top_p",
        type=float,
        default=0.95,
        help="Top-p sampling (default: 0.95)",
    )
    parser.add_argument(
        "--min_p",
        type=float,
        default=None,
        help="Min-p sampling threshold (default: None)",
    )
    parser.add_argument(
        "--device",
        default="cuda",
        choices=["cuda", "cpu"],
        help="Device for model inference (default: cuda)",
    )
    parser.add_argument(
        "--list-ports",
        action="store_true",
        help="List available MIDI ports and exit",
    )
    parser.add_argument(
        "--mode",
        choices=["clock", "manual"],
        default="clock",
        help="Bridge mode: 'clock' uses Ableton MIDI clock (default), 'manual' uses keyboard start/stop",
    )
    parser.add_argument(
        "--manual-key",
        default="r",
        help="Keyboard key to start/stop recording in manual mode (default: r)",
    )
    parser.add_argument(
        "--max-seconds",
        type=float,
        default=None,
        help="Manual mode: optional safety timeout to stop recording after N seconds",
    )
    parser.add_argument(
        "--max-bars",
        type=int,
        default=None,
        help="Manual mode: optional safety timeout expressed in bars (requires tempo inference)",
    )
    parser.add_argument(
        "--max-new-tokens",
        type=int,
        default=None,
        help="Override token budget for generation (otherwise derived from --gen_seconds; higher = longer/more detail)",
    )
    parser.add_argument(
        "--play-key",
        default=None,
        help="Manual mode: optional keyboard key to arm playback of generated MIDI (defaults to auto-play).",
    )
    parser.add_argument(
        "--m4l",
        action="store_true",
        help="Enable OSC control plane for Max for Live (optional, default off)",
    )
    parser.add_argument(
        "--osc-host",
        default="127.0.0.1",
        help="OSC host (default: 127.0.0.1)",
    )
    parser.add_argument(
        "--osc-in-port",
        type=int,
        default=9000,
        help="OSC UDP port to listen for incoming control (default: 9000)",
    )
    parser.add_argument(
        "--osc-out-port",
        type=int,
        default=9001,
        help="OSC UDP port to send status/logs (default: 9001)",
    )
    parser.add_argument(
        "--ui",
        action="store_true",
        help="Launch optional Tkinter UI panel for live control/status",
    )
    parser.add_argument(
        "--feedback",
        action="store_true",
        help="Enable real-time feedback dataset capture mode",
    )
    parser.add_argument(
        "--data-dir",
        type=str,
        default=None,
        help="External directory for storing feedback dataset",
    )

    args = parser.parse_args()

    # Handle port listing early to avoid requiring checkpoint or other setup
    if args.list_ports:
        get_midi_ports()
        return 0

    # Validation: feedback mode requires data directory
    if args.feedback and args.data_dir is None:
        print("Error: --data-dir must be specified when using --feedback")
        sys.exit(1)

    # Validation: checkpoint is required unless feedback-only mode
    if args.checkpoint is None and not args.feedback:
        print("Error: --checkpoint must be specified. Use --checkpoint /path/to/model.safetensors")
        print("Example: python ableton_bridge.py --checkpoint ../models/model-gen.safetensors --in ARIA_IN --out ARIA_OUT")
        sys.exit(1)

    if args.feedback:
        data_dir = Path(args.data_dir)
        data_dir.mkdir(parents=True, exist_ok=True)
        print(f"[Feedback] Using dataset directory: {data_dir}")
        datastore = DataStore(data_dir)
        feedback_manager = FeedbackManager(datastore)
    else:
        feedback_manager = None

    # Import and start bridge
    try:
        # Handle both module and script execution (with new directory structure)
        try:
            from .core.midi_buffer import RollingMidiBuffer
            from .core.aria_engine import AriaEngine
            from .core.bridge_engine import AbletonBridge
            from .core.tempo_tracker import TempoTracker
            from .core.sampling_state import SamplingState, SessionState
            from .modes.manual_mode import ManualModeSession
            from .modes.sampling_hotkeys import start_sampling_hotkeys
            from .modes.osc_controller import OscController
            from .ui.ui_panel import run_ui
            import_mode = "package"
        except ImportError:
            from core.midi_buffer import RollingMidiBuffer
            from core.aria_engine import AriaEngine
            from core.bridge_engine import AbletonBridge
            from core.tempo_tracker import TempoTracker
            from core.sampling_state import SamplingState, SessionState
            from modes.manual_mode import ManualModeSession
            from modes.sampling_hotkeys import start_sampling_hotkeys
            from modes.osc_controller import OscController
            from ui.ui_panel import run_ui
            import_mode = "script"

        logger.debug(f"Import mode: {import_mode}")

        # Shared state + queues (init before heavy model load so OSC can sync immediately)
        sampling_state = SamplingState(
            temperature=args.temperature,
            top_p=args.top_p,
            min_p=args.min_p if args.min_p is not None else 0.0,
        )
        session_state = SessionState(mode=args.mode)
        cmd_queue = queue.Queue()
        log_queue = queue.Queue()
        hotkey_stop = threading.Event()

        osc = None
        startup_state = None
        if args.m4l:
            osc = OscController(
                host=args.osc_host,
                in_port=args.osc_in_port,
                out_port=args.osc_out_port,
                sampling_state=sampling_state,
                session_state=session_state,
                command_queue=cmd_queue,
                commit_cb=(feedback_manager.commit if feedback_manager else None),
                grade_cb=(feedback_manager.set_grade if feedback_manager else None),
            )
            # Start OSC server first, then pull current dial state from Max
            osc.start()
            startup_state = sync_state_on_startup(osc, timeout=2.0)
            if startup_state:
                logger.info(f"OSC params after startup sync: {startup_state}")

        # Verify CUDA if needed (after OSC server is alive)
        if args.device == "cuda":
            import torch
            if not torch.cuda.is_available():
                logger.error("CUDA requested but not available. Use --device cpu")
                return 1
            logger.info(f"CUDA device: {torch.cuda.get_device_name(0)}")

        checkpoint_path = find_checkpoint(args.checkpoint)

        # Keyboard hotkeys (after OSC sync so defaults reflect Max state)
        start_sampling_hotkeys(sampling_state, hotkey_stop)

        logger.info(f"Connecting to ports: IN={args.in_port}, OUT={args.out_port}")
        logger.info(f"Checkpoint: {checkpoint_path}")
        logger.info(
            f"Listen {args.listen_seconds}s -> Generate {args.gen_seconds}s -> "
            f"Cooldown {args.cooldown_seconds}s"
        )
        if args.mode == "manual":
            logger.info("Manual mode selected: keyboard-driven recording without MIDI clock.")
        else:
            if args.clock_in:
                logger.info(f"MIDI Clock input: {args.clock_in}")

        # Create shared engine
        engine = AriaEngine(
            checkpoint_path=checkpoint_path,
            device=args.device,
            config_name="medium",
        )

        if osc:
            osc.send_status(session_state.status if hasattr(session_state, "status") else "IDLE")
            osc.send_params()

        if args.mode == "manual":
            session = ManualModeSession(
                in_port_name=args.in_port,
                out_port_name=args.out_port,
                aria_engine=engine,
                manual_key=args.manual_key,
                ticks_per_beat=args.ticks_per_beat,
                gen_seconds=args.gen_seconds,
                max_seconds=args.max_seconds,
                max_bars=args.max_bars,
                beats_per_bar=args.beats_per_bar,
                max_new_tokens=args.max_new_tokens,
                play_key=args.play_key,
                sampling_state=sampling_state,
                command_queue=cmd_queue if (args.ui or args.m4l) else None,
                log_queue=log_queue if (args.ui or args.m4l) else None,
                session_state=session_state if (args.ui or args.m4l) else None,
                osc_status_cb=osc.send_status if osc else None,
                osc_log_cb=osc.send_log if osc else None,
                osc_params_cb=osc.send_params if osc else None,
                play_gate=bool(args.m4l),
                feedback_manager=feedback_manager,
            )
            if args.ui:
                session_thread = threading.Thread(target=session.run, daemon=True)
                session_thread.start()
                try:
                    run_ui(sampling_state, session_state, cmd_queue, log_queue, stop_event=hotkey_stop)
                finally:
                    hotkey_stop.set()
                    session.cancel_event.set()
                    session_thread.join(timeout=2)
                return 0
            else:
                rc = session.run()
                hotkey_stop.set()
                return rc

        # CLOCK MODE (existing behavior)
        buffer = RollingMidiBuffer(window_seconds=args.listen_seconds)

        # Start tempo tracker only if NOT using clock_in (they conflict on same MIDI port)
        tempo_tracker = None
        if args.clock_in:
            logger.info(f"Using ClockGrid on '{args.clock_in}'; disabling TempoTracker (port conflict)")
        else:
            if args.clock_in:
                try:
                    tempo_tracker = TempoTracker(clock_port_name=args.clock_in)
                    tempo_tracker.start()
                    logger.info(f"Tempo tracker started on '{args.clock_in}'")
                except Exception as e:
                    logger.warning(f"Failed to start tempo tracker: {e}. Continuing without tempo sync.")
        
        bridge = AbletonBridge(
            in_port_name=args.in_port,
            out_port_name=args.out_port,
            midi_buffer=buffer,
            aria_engine=engine,
            tempo_tracker=tempo_tracker,
            sampling_state=sampling_state,
            clock_in=args.clock_in,
            measures=args.measures,
            beats_per_bar=args.beats_per_bar,
            gen_measures=args.gen_measures,
            human_measures=args.human_measures,
            cooldown_seconds=args.cooldown_seconds,
            temperature=args.temperature,
            top_p=args.top_p,
            min_p=args.min_p,
            quantize=args.quantize,
            ticks_per_beat=args.ticks_per_beat,
            feedback_manager=feedback_manager,
        )

        if args.ui:
            bridge_thread = threading.Thread(target=bridge.run, daemon=True)
            bridge_thread.start()
            try:
                run_ui(sampling_state, session_state, cmd_queue, log_queue, stop_event=hotkey_stop)
            finally:
                hotkey_stop.set()
            return 0
        else:
            bridge.run()
            hotkey_stop.set()
            return 0

    except FileNotFoundError as e:
        logger.error(str(e))
        return 1
    except Exception as e:
        logger.exception(f"Fatal error: {e}")
        return 1


if __name__ == "__main__":
    sys.exit(main())
